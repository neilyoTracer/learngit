# Introduce
Java分为3个体系
[JavaSE](J2SE)（Java2 Platform Standard Edition，java平台标准版）
[JavaEE](J2EE) (Java 2 Platform,Enterprise Edition，java平台企业版)
[JavaME](J2ME)(Java 2 Platform Micro Edition，java平台微型版)

# Java 常量
在 Java 中使用 [final] 关键字来修饰常量，声明方式和变量类似：
```java
final double PI = 3.1415927;
```

# 静态变量
由于静态变量是与类相关的，因此可以通过类名来访问静态变量，也可以通过实例名来访问静态变量。
```java
MyClass.count = 10; // 通过类名访问
MyClass obj = new MyClass();
obj.count = 20; // 通过实例名访问
```

# 静态变量的线程安全性
Java 中的静态变量是属于类的，而不是对象的实例。因此，当多个线程同时访问一个包含静态变量的类时，需要考虑其线程安全性。

静态变量在内存中只有一份拷贝，被所有实例共享。因此，如果一个线程修改了静态变量的值，那么其他线程在访问该静态变量时也会看到修改后的值。这可能会导致并发访问的问题，因为多个线程可能同时修改静态变量，导致不确定的结果或数据一致性问题。

为了确保静态变量的线程安全性，需要采取适当的同步措施，如同步机制、原子类或 volatile 关键字，以便在多线程环境中正确地读取和修改静态变量的值。

# 访问控制修饰符

[default] 即默认，什么也不写: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。

[private] : 在同一类内可见。使用对象：变量、方法。 注意：[不能]修饰类（[外部类]）

[public] : 对所有类可见。使用对象：类、接口、变量、方法

[protected] : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：[不能]修饰类（[外部类]）

<Java 程序的 main() 方法必须设置成公有的，否则，Java 解释器将不能运行该类。>

🧠 小技巧：如何记住 protected？
你可以这样理解：

[protected] 就像一个“家族成员专用通道”：

同一个包 = 一个家族 → 你可以直接访问。

子类 = 继承血缘 → 即使搬出去（不同包），也仍然可以通过“[家庭身份]”访问。

外人（非子类、不同包） → 不允许访问。

✅ 一句话总结：
<protected 成员对 同包中的所有类 和 其他包中的子类（通过继承方式） 可见。>

# 访问控制和继承
请注意以下方法继承的规则：

父类中声明为 public 的方法在子类中也必须为 public。

父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。

父类中声明为 private 的方法，不能够被子类继承。

# 非访问修饰符
为了实现一些其他的功能，Java 也提供了许多非访问修饰符。

[static] 修饰符，用来修饰类方法和类变量。

[final] 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。

[abstract] 修饰符，用来创建抽象类和抽象方法。

[synchronized] 和 [volatile] 修饰符，主要用于[多线程]的编程。

# abstract 修饰符
一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。

[抽象类可以包含抽象方法和非抽象方法]。

# synchronized

synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。

实例
```java
public synchronized void showDetails(){
.......
}
```

# Java String 类
String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：

<String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了>

# Java 休眠(sleep)
```java
import java.util.*;
  
public class SleepDemo {
   public static void main(String[] args) {
      try { 
         System.out.println(new Date( ) + "\n"); 
         Thread.sleep(1000 * 3)   // 休眠3秒
         System.out.println(new Date( ) + "\n"); 
      } catch (Exception e) { 
          System.out.println("Got an exception!"); 
      }
   }
}
```
# Java正则表达式
根据 Java Language Specification 的要求，Java 源代码的字符串中的反斜线被解释为 Unicode 转义或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被 Java 字节码编译器解释。例如，当解释为正则表达式时，字符串字面值 "\b" 与单个退格字符匹配，而 "\\b" 与单词边界匹配。字符串字面值 "\(hello\)" 是非法的，将导致编译时错误；要与字符串 (hello) 匹配，必须使用字符串字面值 "\\(hello\\)"。

正则表达式语法
在其他语言中，\\ 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。

在 Java 中，\\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。

所以，在其他的语言中（如 Perl），一个反斜杠 \ 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 \\ 代表其他语言中的一个 \，这也就是为什么表示一位数字的正则表达式是 \\d，而表示一个普通的反斜杠是 \\。

```java
System.out.print("\\");    // 输出为 \
System.out.print("\\\\");  // 输出为 \\
```

# 构造方法
构造方法中的 this 关键字
在构造方法中，this 关键字通常用于两种情况：

1、引用当前对象的属性或方法：当构造方法的参数名与类属性名相同时，使用 this 来区分类属性和参数。例如：

实例
```java
public Person(String name, int age) {
    this.name = name; // this.name 表示类的属性
    this.age = age;
}
```
2、[调用另一个构造方法]：可以使用 this() 调用当前类的其他构造方法，常用于避免重复代码，但必须放在构造方法的第一行。

实例
```java
public Person(String name) {
    this(name, 0); // 调用另一个双参数的构造方法
}

public Person(String name, int age) {
    this.name = name;
    this.age = age;
}
```

# 异常
要理解 Java 异常处理是如何工作的，你需要掌握以下三种类型的异常：

[检查性异常] 这类异常通常使用 try-catch 块来捕获并处理异常，或者在方法声明中使用 throws 子句声明方法可能抛出的异常。
```java
try {
    // 可能会抛出异常的代码
} catch (IOException e) {
    // 处理异常的代码
}

public void readFile() throws IOException {
    // 可能会抛出IOException的代码
}
```

[运行时异常] 这些异常在编译时不强制要求处理，通常是由程序中的错误引起的，例如 NullPointerException、ArrayIndexOutOfBoundsException 等，这类异常可以选择处理，但并非强制要求。

[错误] 错误不是异常，而是脱离程序员控制的问题，错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。

所有的异常类是从 java.lang.Exception 类继承的子类。

[Exception] 类是 [Throwable] 类的子类。除了Exception类外，Throwable还有一个子类[Error] 。

Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。

Error 用来指示运行时环境发生的错误。

例如，JVM 内存溢出。一般地，程序不会从错误中恢复。

异常类有两个主要的子类：[IOException] 类和 [RuntimeException] 类。

# try-with-resouces
JDK7 之后，Java 新增的 try-with-resource 语法结构，旨在自动管理资源，确保资源在使用后能够及时关闭，避免资源泄露 。

try-with-resources 是一种异常处理机制，它能够自动关闭在 try 块中声明的资源，无需显式地在 finally 块中关闭。

在 try-with-resources 语句中，你只需要在 try 关键字后面声明资源，然后跟随一个代码块。无论代码块中的操作是否成功，资源都会在 try 代码块执行完毕后自动关闭。
```java
try (resource declaration) {
  // 使用的资源
} catch (ExceptionType e1) {
  // 异常块
}
```

# 继承
类继承 extends 
接口继承 implements

## super与this关键字
[super] 关键字：我们可以通过 super 关键字来实现对父类成员的访问，用来引用当前对象的父类。
[this] 关键字：指向自己的引用，引用当前对象，即它所在的方法或构造函数所属的对象实例。。
```java
class Animal {
    void eat() {
        System.out.println("animal : eat");
    }
}
 
class Dog extends Animal {
    void eat() {
        System.out.println("dog : eat");
    }
    void eatTest() {
        this.eat();   // this 调用自己的方法
        super.eat();  // super 调用父类方法
    }
}
 
public class Test {
    public static void main(String[] args) {
        Animal a = new Animal();
        a.eat();
        Dog d = new Dog();
        d.eatTest();
    }
}

// output
animal : eat
dog : eat
animal : eat

```

## final关键字
使用 final 关键字声明类，就是把类定义定义为[最终类]，[不能被继承]，或者用于[修饰方法]，该方法[不能被子类重写]

## 构造器
子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。[如果父类的构造器带有参数]，则必须在子类的构造器中[显式]地通过 [super] 关键字[调用]父类的构造器并配以适当的参数列表。

```java
class SuperClass {
    private int n;
 
    // 无参数构造器
    public SuperClass() {
        System.out.println("SuperClass()");
    }
 
    // 带参数构造器
    public SuperClass(int n) {
        System.out.println("SuperClass(int n)");
        this.n = n;
    }
}
 
// SubClass 类继承
class SubClass extends SuperClass {
    private int n;
 
    // 无参数构造器，自动调用父类的无参数构造器
    public SubClass() {
        System.out.println("SubClass()");
    }
 
    // 带参数构造器，调用父类中带有参数的构造器
    public SubClass(int n) {
        super(300);
        System.out.println("SubClass(int n): " + n);
        this.n = n;
    }
}
 
// SubClass2 类继承
class SubClass2 extends SuperClass {
    private int n;
 
    // 无参数构造器，调用父类中带有参数的构造器
    public SubClass2() {
        super(300);
        System.out.println("SubClass2()");
    }
 
    // 带参数构造器，自动调用父类的无参数构造器
    public SubClass2(int n) {
        System.out.println("SubClass2(int n): " + n);
        this.n = n;
    }
}
 
public class TestSuperSub {
    public static void main(String[] args) {
        System.out.println("------SubClass 类继承------");
        SubClass sc1 = new SubClass();
        SubClass sc2 = new SubClass(100);
 
        System.out.println("------SubClass2 类继承------");
        SubClass2 sc3 = new SubClass2();
        SubClass2 sc4 = new SubClass2(200);
    }
}
```

# 虚函数
虚函数的存在是为了多态。

Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。