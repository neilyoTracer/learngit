/**
 * invert(x,p,n)该函数返回对x执行下列操作后的结果
 * 这个从p位开始是从左至右
 * 将x中从p位开始的n个位求反，x的其余位不变
 * 思路先建立从p开始的n个屏蔽码
 * 00011100 的mask
 * 然后 x ^ 这个mask 相同得0不同得1
 */
unsigned invert(unsigned x, int p, int n) 
{
    /**
     * as x=010 100 10 82 p=4, n=3, result=01001110 42
     * 0000 0000 ～
     * 1111 1111 << 3
     * 1111 1000 ~
     * 0000 0111 << p + 1 -n
     * 0001 1100 ^ 010 100 10
     * 010 011 10
     */
    unsigned mask = ~(~0 << n) << (p+1-n);
    return x ^ mask;
}