开发填坑手册

1.ng build --aot 只打包不压缩 用来检查线上报错
2.http://localhost:4200/null 报错,检查图片是否有默认路径（未找到资源后的默认路径）
3.nz-select 必须在formControl或者ngModel指令时才会触发ngModelChange 但是响应式表单推荐有control.valueChange 或者control.stateChange 等 Obserable对象
4.ERROR Error: Uncaught (in promise): Error: StaticInjectorError(Webapp AppModule)[InjectionToken nz-i18n] - 此错误是因为未在根模块导入ng-zorro或导入后未正确按官网配置i18n令牌
----
5.端口被占用

C:\WINDOWS\system32>netstat -aon|findstr "9000"
  TCP    0.0.0.0:9000           0.0.0.0:0              LISTENING       14512
  TCP    127.0.0.1:9000         0.0.0.0:0              LISTENING       5368
  TCP    [::]:9000              [::]:0                 LISTENING       14512

C:\WINDOWS\system32>tasklist|findstr "14512"
node.exe                     14512 Console                    1     22,716 K

C:\WINDOWS\system32>tasklist|findstr "5368"
TransHost.exe                 5368 Services                   0      5,040 K

C:\WINDOWS\system32>taskkill /pid 5368 /f
成功: 已终止 PID 为 5368 的进程。

Mac:
1.查找端口进程

lsof -i:8000
2.终止进程 kill + pid

kill 85877


----

6.Can't resolve all parameters for ConfirmComponent: ([object Object], ?, [object Object])类似报错解决方法
constructor(@Inject(forwardRef(() => MobileService)) public ms: MobileService) {
   console.log(ms);
}

将@inject（forwardRef（（）=>MobileService））添加到原始问题源代码中构造函数的参数将解决此问题。

-----------------

7.当始终遇到git代码库权限问题时,使用
git credential-manager uninstall #解决权限冲突问题
git config --global credential.helper store #解决每次拉代码都需要输入密码


-----------------

8.普通script标签是可以加载跨域脚本的,但如果给跨域script标签添加了crossorigin属性
(且服务器端没有设置Access-Control-Allow-Origin响应头)就会出现如下错误:
Access to Script at 'http://127.0.0.1:8081/index.js' from origin 'http://127.0.0.1:8081' has been blocked by CORS(cross origin resource sharing) policy:
No 'Access-Control-Allow-Origin' header is present on the requested resource.
Origin 'http://127.0.0.1:8081' is therefore not allowed access 

--------------------------

9.react 组件返回只能有一个根元素。这也是我们要用一个<div>来包裹所有<Welcome />元素的原因。或者用<></>包裹

--------------------------


10.git dist 目录排除不了
问题描述
在有的项目中，需要排除 dist 目录不被 git 管理，
一般都是在 .gitignore 文件 添加 ‘dist/’;但是有的时候发现没用。

解决方案
原因是首次提交可能就将 dist 增加到了 git 仓库，
所以检查下 git 仓库如果有 dist 目录，然后将 git仓库的 dist 目录删除，
再 pull 本地合并，最后 dist 目录就排除了管理


--------------------- 

11.关于index.xxx集中导出本目录文件的问题:
如果用了index.xxx集中导出本目录的文件，文件里的文件如果有互相依赖，就用相对目录去引用，不然会造成bug

----------------------


12.关于 ExpressionChangedAfterItHasBeenCheckedError

一般再dom更新之前改组件绑定的数据不会出这个错误，比如ngOninit里改，但再dom更新之后再改值就会出问题，比如ngAfterViewInit里改dom绑定数据
这时候用setTimeout来解决问题


----------------------


13.关于rem做适配

有时我们会看到有些使用rem的页面里会先给页面根元素一个样式：

html {font-size: 62.5%; /*10 ÷ 16 × 100% = 62.5%*/}
为什么是62.5%？

大多数浏览器的默认字号是16px，因此1rem=16px，这样不方便我们px和rem的换算，假设1rem=10px，那么100px=10rem，25px=0.25rem。这样就好换算很多，于是就有了上面的10/16。

如果是640的设计稿，需要除以2转化为和iphone5屏幕等宽的320。所以设计稿px单位/2/10转为rem。之后再媒体查询设置每个屏幕大小的font-size百分比，页面会根据上面设置的根font-size适配。

看到这里是不是觉得一切很完美？然而，这里面有两个深坑：

1.我看了网上很多关于rem的资料，基本都说浏览器的默认字号就是16px，然后直接定义font-size:62.5%。但是，rem属于css3的属性，有些浏览器的早期版本和一些国内浏览器的默认字号并不是16px，那么上面的10/16换算就不成立，直接给html定义font-size: 62.5%不成立。

2.chrome强制字体最小值为12px，低于12px按12px处理，那上面的1rem=10px就变成1rem=12px，出现偏差（下面给demo）。

解决方案： 将1rem=10px换为1rem=100px（或者其它容易换算的比例值）;不要在pc端使用rem。

那么上面的页面根元素样式要改为：

html {font-size: 625%; /*100 ÷ 16 × 100% = 625%*/}
再用本工厂总结得出的各分辨率媒体查询换算：

@media screen and (min-width:360px) and (max-width:374px) and (orientation:portrait) {
    html { font-size: 703%; }
}
@media screen and (min-width:375px) and (max-width:383px) and (orientation:portrait) {
    html { font-size: 732.4%; }
}
@media screen and (min-width:384px) and (max-width:399px) and (orientation:portrait) {
    html { font-size: 750%; }
}
@media screen and (min-width:400px) and (max-width:413px) and (orientation:portrait) {
    html { font-size: 781.25%; }
}
@media screen and (min-width:414px) and (max-width:431px) and (orientation:portrait){
    html { font-size: 808.6%; }
}
@media screen and (min-width:432px) and (max-width:479px) and (orientation:portrait){
    html { font-size: 843.75%; }
}
看看这个例子: https://cloud.tencent.com/developer/article/1388306

javascript控制
// 设计图为2560,情况下1rem = 100px; // 640以下全部不用再适配
// if (clientWidth >= 1920 || clientWidth <= 1024) {
let _rem = doc.documentElement.clientWidth / 25.6;
if (_rem < 60) {
    _rem = 60;
}
docEl.style.fontSize = _rem + 'px';

----------------------------------------

14. 在用nz-menu做导航时, 可以用一个a元素当做浮层,覆盖整个li,来做路由跳转,避免只能点字体跳转的尴尬


-----------------------------------------

15. 在使用观察者对象的时候,传给Observable的observer => { }订阅函数参数,在rxjs内部对这个函数的参数observer进行了封装
使用Subscriber类,new Subscriber(observer),这样之后observer实际上就拥有了这个Subscriber的上下文,所以在函数体内部,执行next回调的时候
必须显示的写出observer.next来执行,不能把observer直接赋值给一个字面量对象,不然的话rxjs内部会丢失上下文抛错
具体例子写法:

createLocationObservable(): Observable<any> {
        return Observable.create(observer => {
            // const { next, error } = observer;  
            const geoOptions = {
                enableHighAccuracy: true,
                maximumAge: 30000,
                timeout: 27000
            };
            let watchId;

            if ('geolocation' in navigator) {
                watchId = navigator.geolocation.watchPosition(
                    position => observer.next(position), // 如果这里直接写next,就要报错
                    error => observer.error('locate faild'),
                    geoOptions
                );
            } else {
                observer.error('locate faild');
            }

            return { unsubscribe() { navigator.geolocation.clearWatch(watchId); } };
        });
    }


-----------------------------------------------------------------------------------------------


16.npm每次重新安装包的时候把,比如重新安装本地包时npm install --save ../xxx.tgz 本地包需要删除package-lock.json,不然会依照这个文件直接执行上次的整个package.json安装
package-lock.json 可以用于锁定当前npm包版本
另外如果安装包时报错Unexpected end of JSON input while parsing near '...^0.5.0","mocha":"^1.2',类似这样的错解决方法:
npm cache clean --force


---------------------------------------------------------------------------------------------------

17.linux 上删除文件夹下的所有文件
[jiangxd@mpdev-itraffic-front-end dev]$ sudo -s rm -rf /opt/dev/docke-compose/dockerProdApp/*
[sudo] password for jiangxd: 
[jiangxd@mpdev-itraffic-front-end dev]$ 

-------------------------------------------------------------------------------------------------------

18. 解决google浏览器input auto-fill样式问题

// 需要黑色背景的input
input:-webkit-autofill {
	-webkit-box-shadow: 0 0 0px 1000px #313133 inset;
	-webkit-text-fill-color: #ffffff !important;
	border: 1px solid #797979 !important;
	outline: none !important;
}



----------------------------------------------------------------------------------------------------------

20. 箭头函数不能new,不然会报错
ex: 
this.Layout.registerComponent('multi-layout', function(container, state) {
			
		});
这里的回调函数如果写成箭头函数在Golden Layout 源码中作为构造函数使用,会导致源码报
ComponentConstructor is not a Constructor的错误


----------------------------------------------------------------------------------------------------------


21. 为什么惰性加载模块会创建一个子注入器？
Angular 会把 @NgModule.providers 中的提供商添加到应用的根注入器中…… 除非该模块是惰性加载的，这种情况下，Angular 会创建一子注入器，并且把该模块的提供商添加到这个子注入器中。

这意味着模块的行为将取决于它是在应用启动期间加载的还是后来惰性加载的。如果疏忽了这一点，可能导致严重后果。

为什么 Angular 不能像主动加载模块那样把惰性加载模块的提供商也添加到应用程序的根注入器中呢？为什么会出现这种不一致？

归根结底，这来自于 Angular 依赖注入系统的一个基本特征： 在注入器还没有被第一次使用之前，可以不断为其添加提供商。 一旦注入器已经创建和开始交付服务，它的提供商列表就被冻结了，不再接受新的提供商。

当应用启动时，Angular 会首先使用所有主动加载模块中的提供商来配置根注入器，这发生在它创建第一个组件以及注入任何服务之前。 一旦应用开始工作，应用的根注入器就不再接受新的提供商了。

之后，应用逻辑开始惰性加载某个模块。 Angular 必须把这个惰性加载模块中的提供商添加到某个注入器中。 但是它无法将它们添加到应用的根注入器中，因为根注入器已经不再接受新的提供商了。 于是，Angular 在惰性加载模块的上下文中创建了一个新的子注入器。


----------------------------------------------------------------------------------------------------------

22. 判断数组长度，切记不要用 === [] ，永远不要判断两个对象全等，始终会返回false


----------------------------------------------------------------------------------------------------------

23. Mac 运行npm报错，
> fsevents@1.2.9 install /Users/huanghuarui/work/project/hr-gulp-demo/node_modules/fsevents
> node install

node-pre-gyp WARN Using needle for node-pre-gyp https download 
node-pre-gyp WARN Pre-built binaries not installable for fsevents@1.2.9 and node@10.16.3 (node-v64 ABI, unknown) (falling back to source compile with node-gyp) 


node-pre-gyp WARN Hit error EACCES: permission denied, mkdir '/Users/huanghuarui/work/project/hr-gulp-demo/node_modules/fsevents/lib' 
gyp ERR! configure error 
gyp ERR! stack Error:        EACCES: permission denied, mkdir '/Users/huanghuarui/work/project/hr-gulp-demo/node_modules/fsevents/build'


gyp ERR! System Darwin 18.7.0
gyp ERR! command "/usr/local/bin/node" "/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js" "configure" "--fallback-to-build" "--module=/Users/huanghuarui/work/project/hr-gulp-demo/node_modules/fsevents/lib/binding/Release/node-v64-darwin-x64/fse.node" "--module_name=fse" "--module_path=/Users/huanghuarui/work/project/hr-gulp-demo/node_modules/fsevents/lib/binding/Release/node-v64-darwin-x64" "--napi_version=4" "--node_abi_napi=napi" "--napi_build_version=0" "--node_napi_label=node-v64"
gyp ERR! cwd /Users/huanghuarui/work/project/hr-gulp-demo/node_modules/fsevents
gyp ERR! node -v v10.16.3
gyp ERR! node-gyp -v v3.8.0
gyp ERR! not ok 
node-pre-gyp ERR! build error 
node-pre-gyp ERR! stack Error: Failed to execute '/usr/local/bin/node /usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js configure --fallback-to-build --module=/Users/huanghuarui/work/project/hr-gulp-demo/node_modules/fsevents/lib/binding/Release/node-v64-darwin-x64/fse.node --module_name=fse --module_path=/Users/huanghuarui/work/project/hr-gulp-demo/node_modules/fsevents/lib/binding/Release/node-v64-darwin-x64 --napi_version=4 --node_abi_napi=napi --napi_build_version=0 --node_napi_label=node-v64' (1)
node-pre-gyp ERR! stack     at ChildProcess.<anonymous> (/Users/huanghuarui/work/project/hr-gulp-demo/node_modules/fsevents/node_modules/node-pre-gyp/lib/util/compile.js:83:29)
node-pre-gyp ERR! stack     at ChildProcess.emit (events.js:198:13)
node-pre-gyp ERR! stack     at maybeClose (internal/child_process.js:982:16)
node-pre-gyp ERR! stack     at Process.ChildProcess._handle.onexit (internal/child_process.js:259:5)
node-pre-gyp ERR! System Darwin 18.7.0
node-pre-gyp ERR! command "/usr/local/bin/node" "/Users/huanghuarui/work/project/hr-gulp-demo/node_modules/fsevents/node_modules/node-pre-gyp/bin/node-pre-gyp" "install" "--fallback-to-build"
node-pre-gyp ERR! cwd /Users/huanghuarui/work/project/hr-gulp-demo/node_modules/fsevents
node-pre-gyp ERR! node -v v10.16.3
node-pre-gyp ERR! node-pre-gyp -v v0.12.0
node-pre-gyp ERR! not ok 
Failed to execute '/usr/local/bin/node /usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js configure --fallback-to-build --module=/Users/huanghuarui/work/project/hr-gulp-demo/node_modules/fsevents/lib/binding/Release/node-v64-darwin-x64/fse.node --module_name=fse --module_path=/Users/huanghuarui/work/project/hr-gulp-demo/node_modules/fsevents/lib/binding/Release/node-v64-darwin-x64 --napi_version=4 --node_abi_napi=napi --napi_build_version=0 --node_napi_label=node-v64' (1)
npm WARN hr-gulp-demo@1.0.0 No repository field.
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules/fsevents):
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 install: `node install`
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: Exit status 1

+ gulp@4.0.2
+ gulp-typescript@5.0.1
+ typescript@3.6.3
added 6 packages from 55 contributors, updated 1 package and audited 6789 packages in 136.096s
found 0 vulnerabilities

huanghuaruideMacBook-Pro-2:hr-gulp-demo huanghuarui$ 
huanghuaruideMacBook-Pro-2:hr-gulp-demo huanghuarui$ 
huanghuaruideMacBook-Pro-2:hr-gulp-demo huanghuarui$ sudo npm install --save-dev typescript gulp gulp-typescript --unsafe-perm=true --allow-root
Password:

> fsevents@1.2.9 install /Users/huanghuarui/work/project/hr-gulp-demo/node_modules/fsevents 
这种情况只会发生在你用sudo -i 模式下创建的项目目录内
一般情况，执行sudo npm install 命令不会用这个问题

----------------------------------------------------------------------------------------------------------

24.angular 提供商数组简写
providers:[Logger]
providers:[{ provide: Logger, useClass: Logger }] 
⚠️注意不要拼错 是provide
不然报错
⚠️ Invalid provider for the NgModule 'DynamicTestModule' - only instances of Provider and Type are allowed, got: [?[object Object]?, ...]

__________________________________________________________________________________________________________

25.查看npm 全局安装包
npm list -g -depth=0
npm ls -g -depth=0

__________________________________________________________________________________________________________

26.nzTable报错
EquipmentListComponent.html:57 ERROR Error: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: 'ngForOf: '. Current value: 'ngForOf: [object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]'.
检查是否模版变量重复

__________________________________________________________________________________________________________


27. 还能看懂闭包吗
[1,2,3].forEach(item => {
   const a = item;
   test(() => console.log(a))
});
function test(cb) {
  setTimeout(() => cb(), 5000)
}

// 5秒后依次打出1，2，3

__________________________________________________________________________________________________________


27. angular post formdata
不要加任何Content-Type请求头，让其自动生成，不然会覆盖原生的请求头

__________________________________________________________________________________________________________


28. NullInjectorError: No provider for PagerService
如果服务注入没有问题，检查是否有注入的全局单例服务注入了模块级提供商，此时会报这个错误，在模块级组件再注入此模块级提供商
解决办法，将模块级提供商改为全局提供商

__________________________________________________________________________________________________________


29.页面无缘无故刷新有可能是表单提交造成的（注意button的type）

__________________________________________________________________________________________________________


30.geoserver返回的gis feature数据，如果用addFeatures()方法不能触发style回调的话，试一试给加入如下代码
const coords = [feature.get('longitude'), feature.get('latitude')];
feature['values_']['geometry'] = new Point(coords);

__________________________________________________________________________________________________________




31.用数组的some或者every方法让数组迭代提前结束



__________________________________________________________________________________________________________


32*. Must supply a value for form control with name: 'messageType'
此报错是由于formControl类的实例在调用setValue和pathValue结构对应不上时造成的报错，很隐蔽


__________________________________________________________________________________________________________


Openlayer
33. select Interaction clear when relative layer close
```
// clear Select interaction selected feature before close layer
        const interactions = this.mapMain.getInteractions().getArray() as Array<any>;
        interactions.some(interaction => {
            if (interaction instanceof Select) {
                interaction.getFeatures().clear();
                return true;
            }
        });
```

__________________________________________________________________________________________________________

34. **注意concat操作不会改变原数组

__________________________________________________________________________________________________________

35. **注意rxjs数据流内部如果不catchError，pipe内部报错会导致整个流中断，且无法再继续下次流

__________________________________________________________________________________________________________


36. error: Arguments array must have arguments....	
出现此错误，请检查angular依赖注入，可能两个类之前相互引用了，就会出现这个错

__________________________________________________________________________________________________________

37. js事件循环机制
•来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。
•事件循环的顺序，决定了JavaScript代码的执行顺序。它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的micro-task。当所有可执行的micro-task执行完毕之后。循环再次从macro-task开始，找到其中一个任务队列执行完毕，然后再执行所有的micro-task，这样一直循环下去。
•其中每一个任务的执行，无论是macro-task还是micro-task，都是借助函数调用栈来完成。纯文字表述确实有点干涩，因此，这里我们通过2个例子，来逐步理解事件循环的具体顺序。

__________________________________________________________________________________________________________

38. 确定某个字母在某些字母范围内
const name = 'S'
const isInAToM = name < 'N';
eg: 'ADW' < 'S' => true

__________________________________________________________________________________________________________

39. 正则表达式中问号的用途
1. ?        #表示 一个 或者 没有
2. ?=       #前瞻: 用法: exp1(?=exp2) 表示后面是exp2的exp1
3. ?!       #负前瞻: 用法: exp1(?!exp2) 表示后面不是exp2的exp1
4. ?<=      #后顾: 用法: (?<=exp2)exp1 表示前面是exp2的exp1
5. ?<!      #负后顾: 用法: (?<!exp2)exp1 表示前面不是exp2的exp1
6. (?:)     表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来
   ()表示捕获分组，()会把每个分组里的匹配的值保存起来，使用$n(n是一个数字，表示第n个捕获组的内容)
// 数字格式化 1,123,000
"1234567890".replace(/\B(?=(?:\d{3})+(?!\d))/g,",") // 结果：1,234,567,890，匹配的是后面是3*n个数字的非单词边界(\B)
解释：3个数字为一组，后面已加逗号，不再是数字
__________________________________________________________________________________________________________

40. openlayer的layer的'change'事件，交互效果是每次变动两次
    需要计数，每偶数次才用rxjs去发送事件

__________________________________________________________________________________________________________


41.window.performance.navigation 对象提供了在指定的时间段里发生的操作相关信息，包括页面是加载还是刷新、发生了多少次重定向等。

属性	含义
type	表示是如何导航到这个页面的
redirectCount	表示在到达这个页面之前重定向了多少次

type的值	含义
0	当前页面是通过点击链接，书签和表单提交，或者脚本操作，或者在url中直接输入地址
1	点击刷新页面按钮或者通过Location.reload()方法显示的页面
2	页面通过历史记录和前进后退访问时
255	任何其他方式

__________________________________________________________________________________________________________


42. Experimental support for decorators is a feature that is subject to change in a future release. Set 
VScode一直出现装饰器报错
解决办法: 
在VSCode的settings.json中设置javascript.implicitProjectConfig.experimentalDecorators为true。

__________________________________________________________________________________________________________

43
1. 任何带算数运算只要有浮点数都会有舍入误差产生
2. Infinity 与 0 相乘, 则结果是NaN
3. null 和 undefined 在和任何数据执行 == 操作之前不会执行任何隐式转换 


__________________________________________________________________________________________________________


44. mouseEvent的offsetX和offsetY是实验属性不要用来做鼠标跟随定位，会出问题，一般用来初始化鼠标定位是可以的


__________________________________________________________________________________________________________


45. 把x限制赋值取a~b范围内的值，包括a,b Math.max(a,Math.min(b, x));


__________________________________________________________________________________________________________


45. 一定要注意在重复执行的函数里使用setTimeout，如果挂载的回调使用了函数的局部变量，则会形成闭包，函数的活动对象会保存在内存当中，
当回调执行的时候，这个变量会是几秒之前的值，如果和现在执行时的变量进行比较，则有可能会不一样

__________________________________________________________________________________________________________


46. error: SyntaxError: Unexpected token   in JSON at position 0 at JSON.parse (<anonymous>) at 
XMLHttpRequest.onLoad (http://localhost:4200/vendor.js:37126:51) at ZoneDelegate.push..[表情]de_modules/zone.js/dist/zone.js.ZoneDelegate.invokeTask (http://localhost:4200/polyfills.js:3428:31) at Object.onInvokeTask (http://localhost:4200/vendor.js:82671:33) at ZoneDelegate.push..[表情]de_modules/zone.js/dist/zone.js.ZoneDelegate.invokeTask (http://localhost:4200/polyfills.js:3427:60) at Zone.push..[表情]de_modules/zone.js/dist/zone.js.Zone.runTask (http://localhost:4200/polyfills.js:3200:47) at ZoneTask.push..[表情]de_modules/zone.js/dist/zone.js.ZoneTask.invokeTask [as invoke] (http://localhost:4200/polyfills.js:3503:34) at invokeTask (http://localhost:4200/polyfills.js:4749:14) at XMLHttpRequest.globalZoneAwareCallback (http://localhost:4200/polyfills.js:4786:21)
message: "Unexpected token   in JSON at position 0"
这个后台接口返回状态码200但报这个错需要修改post请求的responseType

__________________________________________________________________________________________________________


47. **我草泥马，a标签点击下载没反应，看一下是不是在document上面加了click事件，然后preventDefault了，这样会导致无法下载**


__________________________________________________________________________________________________________


48. 注意不要使用rxjs的subscription.add API 某些情况下会导致请求被取消

__________________________________________________________________________________________________________


49. 从一个外部文件引入某个对象后，对象的某些属性丢失了，查看这个对象所在的文件是否存在循环引用的问题

__________________________________________________________________________________________________________

50. {} instanceof Object 报错是因为
因为instanceof 的前操作数 需要是一个对象，
但是{} 同时也是空的代码块，所以js无法识别{}是代码块还是空对象，
--- js 语句优先
优先识别为代码块就报错了。。。
({}) instanceof Object 这样就不会报错


___________________________________________________________________________________________________________


51. input框的oninput事件可以直接拿到用变量value引用input输入值


___________________________________________________________________________________________________________


52. angular属性绑定中html属性和dom属性的区别例子:
disabled Attribute 是另一个例子。按钮的 disabled Property 默认为 false，因此按钮是启用的。

当你添加 disabled Attribute 时，仅仅它的出现就将按钮的 disabled Property 初始化成了 true，因此该按钮就被禁用了。

content_copy
<button disabled>Test Button</button>
添加和删​​除 disabled Attribute 会禁用和启用该按钮。 但是，Attribute 的值无关紧要，这就是为什么您不能通过编写 <button disabled="false">仍被禁用</button> 来启用此按钮的原因。

要控制按钮的状态，请设置 disabled Property，

虽然技术上说你可以设置 [attr.disabled] 属性绑定，但是它们的值是不同的，Property 绑定要求一个布尔值，而其相应的 Attribute 绑定则取决于该值是否为 null 。例子如下：

content_copy
<input [disabled]="condition ? true : false">
<input [attr.disabled]="condition ? 'disabled' : null">
通常，要使用 Property 绑定而不是 Attribute 绑定，因为它更直观（是一个布尔值），语法更短，并且性能更高。

例子2: 
<!-- Notice the colSpan property is camel case -->
<tr><td [colSpan]="2">Span 2 columns</td></tr>

___________________________________________________________________________________________________________


53. angular多个类绑定比较方便的用法:
多个类绑定

[class]="classExpr"	string	"my-class-1 my-class-2 my-class-3"
{[key: string]: boolean | undefined | null}	{foo: true, bar: false}
Array<string>	['foo', 'bar']


___________________________________________________________________________________________________________


54. 内置模板函数
类型转换函数 $any()
有时候，绑定表达式可能会在 AOT 编译时报类型错误，并且它不能或很难指定类型。要消除这种报错，你可以使用 $any() 转换函数来把表达式转换成 any 类型，范例如下：

src/app/app.component.html
content_copy
<p>The item's undeclared best by date is: {{$any(item).bestByDate}}</p>
当 Angular 编译器把模板转换成 TypeScript 代码时，$any 表达式可以防止 TypeScript 编译器在进行类型检查时报错说 bestByDate 不是 item 对象的成员。

$any() 转换函数可以和 this 联合使用，以便访问组件中未声明过的成员。

src/app/app.component.html
content_copy
<p>The item's undeclared best by date is: {{$any(this).bestByDate}}</p>
$any() 转换函数可以用在绑定表达式中任何可以进行方法调用的地方。


___________________________________________________________________________________________________________


55. angular响应式表单写法 fb.group对象单个键的值就是FormControl的参数只是放在一个数组里面实现响应式表单的事件触发方式的代码如下:
this.basicsFm = this.fb.group({
    name: [null, {validators: Validators.required, asyncValidators: this.NameValidator.bind(this), updateOn: 'blur'}],
    description: [null, Validators.required],
    type: [null, Validators.required],
    personInCharge: [''],
    isScheduled: [false]
});

export interface AbstractControlOptions {
    /**
    * List of validators applied to control.
    */
    validators?: ValidatorFn | ValidatorFn[] | null;
    /**
    * List of async validators applied to control.
    */
    asyncValidators?: AsyncValidatorFn | AsyncValidatorFn[] | null;
    /**
    * The event name for control to update upon.
    */
    updateOn?: 'change' | 'blur' | 'submit';
}

附录:
const c = new FormGroup({
 one: new FormControl()
}, { updateOn: 'blur' });

___________________________________________________________________________________________________________


56. 纯管道与纯函数
纯管道使用纯函数。 纯函数是指在处理输入并返回结果时，不会产生任何副作用的函数。 给定相同的输入，它们总是返回相同的输出。

在本章前面讨论的管道都是用纯函数实现的。 内置的 DatePipe 就是一个用纯函数实现的纯管道。 ExponentialStrengthPipe 是如此， FlyingHeroesComponent 也是如此。 不久前你刚看过的 FlyingHeroesImpurePipe 就是一个用纯函数实现的非纯管道。

但是一个纯管道必须总是用纯函数实现。忽略这个警告将导致失败并带来一大堆这样的控制台错误：表达式在被检查后被变更。

___________________________________________________________________________________________________________



57. vscode权限的问题，打开文件夹简介，设置权限(在mac中非特殊情况，不要用sudo -i权限去创建项目)



___________________________________________________________________________________________________________



58. 注意 multi: true 选项。 这个必须的选项会告诉 Angular HTTP_INTERCEPTORS 是一个多重提供者的令牌，表示它会注入一个多值的数组，而不是单一的值。


___________________________________________________________________________________________________________



59.Cannot find module '~/images/slide.svg'. 
  在tsconfig.json的compileOptions加字段"typeRoots": ["types", "node_modules/@types"]，在根目录建立types文件夹新建svgs.d.ts，写入一下代码

```javascript
declare module '*.svg' {
  const content: any;
  export default content;
}
```


___________________________________________________________________________________________________________



60. 两行css代码实现瀑布流
<style scoped> 
  .waterfall-container {    
     /*分几列*/
    column-count: 2;
  }  
 
  .waterfall-item {    
     /*不留白，不知道什么意思可以取消这个样式试试*/
    break-inside: avoid;
  }
</style>


___________________________________________________________________________________________________________



61.在拖拽事件中
要想触发drop事件，必须禁止目标元素的dragover事件的默认行为，因为dragover的默认事件是不戳发drop



___________________________________________________________________________________________________________
  


62. angular依赖注入的服务为undefined除了首先检查this指向问题外，可以检查该服务是否处于循环依赖当中
比如模式us<=ss<=ps<=us



___________________________________________________________________________________________________________



63. ES6解构赋值的用途
1. 交换变量的值
let x = 1,y = 2;
[x, y] = [y, x];



___________________________________________________________________________________________________________



64. 如何登录ftp服务器
在网页上直接输入ftp://xxx.xxx.xxx.xxx



___________________________________________________________________________________________________________



65.利用AbortController取消fetch请求
const abortController = new AbortController();

fetch(url, {
    // 这里传入 signal 进行关联 
    signal: abortController.signal
});

// 这里调用 abort 即可取消请求
abortController.abort();


___________________________________________________________________________________________________________


66.在使用 useEffect 等需要传入依赖的 hook 时，最理想的状况是所有依赖都在真正发生变化的时候才去改变自身的引用地址，
但是有些依赖不太听话，每次渲染都会重新生成一个引用，但是内部的值却没变，这可能会让 useEffect 对于依赖的「浅比较」没法正常工作。

比如说: 
const getDep = () => { 
    return { 
        foo: 'bar'
    }
};

useEffect(() => { 
    // 无限循环了
}, [getDep()]);

这是一个人为的例子，由于 getDeps 函数返回的对象每次执行都是一个全新的引用，所以会导致触发渲染->effect->渲染->effect 的无限更新。
有一个比较取巧的解决办法，把依赖转为字符串：

const getDep = () => { 
    return { 
        foo: 'bar'
    };
} ;

const dep = JSON.stringify(getDep());

useEffect(() => { 
    // ok!
}, [dep])；

___________________________________________________________________________________________________________

67. angular表单，被disable的项目，在value里面是没有字段的，需要通过control才能获得

___________________________________________________________________________________________________________

68. 实现div中的字体或多行字体居中显示
<div class="w170 p015 flex flex-items-center flex-justify-center">
	<span style="text-align: center">{{c.contract}}</span>
</div>


___________________________________________________________________________________________________________

69. 消除Chrome input自动填充样式
// 用padding代替背景，背景渲染切割到盒子不渲染padding
:host ::ng-deep .ant-input-affix-wrapper > input {
	height: 0;
	padding: 20px 100px 20px 0;
	background-clip: content-box;
}

// 改变自动填充字体的样式
:host ::ng-deep .ant-input-affix-wrapper > input::first-line {
	color: #fff;
	font-size: 14px;
	font-family: "Encode Sans Condensed SemiBold", "Encode Sans Condensed", "Encode Sans", "Chinese Quote", -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "Helvetica Neue", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
	font-weight: 500;
	font-variant: tabular-nums;
	list-style: none;
	font-feature-settings: 'tnum';
}
*** 还有个更好的办法，是检查控件的name是否includes 'name' or 'passowrd' 这样也可以避免自动填充

___________________________________________________________________________________________________________


70. 文件批量上传
fileList.forEach((file: any) => {
    formData.append('files', file);
});


___________________________________________________________________________________________________________


70. ngModelChange触发机制 
必须通过用户交互，才会触发，只通过js改变ngModel的绑定值，是不会触发ngModelChange的
注意： 在响应式表单中，只要有valueChange监听，通过js改变值，也会触发监听回调

___________________________________________________________________________________________________________


71.Angular 模板变量的作用域
内部模版可以访问外部父模版的模版变量
<input #ref1 type="text" [(ngModel)]="firstExample" />
<span *ngIf="true">Value: {{ ref1.value }}</span>

<input #ref1 type="text" [(ngModel)]="firstExample" />

<!-- New template -->
<ng-template [ngIf]="true">
  <!-- Since the context is inherited, the value is available to the new template -->
  <span>Value: {{ ref1.value }}</span>
</ng-template>


外部父模版不可以访问内部模版的模版变量
<input *ngIf="true" #ref2 type="text" [(ngModel)]="secondExample" />
<span>Value: {{ ref2?.value }}</span> <!-- doesn't work -->


___________________________________________________________________________________________________________


72. array.fill(item) 
注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。
比如fill([]),这个时候，如果往一个元素里push，其他元素都会造成影响
这时候可以用fill(null).map(() => []);


___________________________________________________________________________________________________________


73. word-break: break-word 解决，默认值好像是inherit还是normal
连续英文字符没有空格，html认为是一个单词，会导致不换行


___________________________________________________________________________________________________________


74. Can't construct a query for the property "xxx" of "xxxComponent" since the query selector wasn't defined"
此错误检查是否有循环引用的问题，特别是文件夹内有index.ts导出后，本文件夹范围内文件引用还在用全局绝对路径引用，
此时改成相对路径即可解决


___________________________________________________________________________________________________________


75. 在angular里使用openlayer，通过@Input传递 mapid的时候，注意不要在ngOnInit生命周期内初始化地图，因为这个时候dom的Id还没有
经过变更检查，无法通过该mapid获取到dom，所以只有等到ngAfterViewInit才行


___________________________________________________________________________________________________________



76. angular突然间路由跳转出现问题，但又始终不报错，有可能是模版报错了，第一时间检查入口组件的模板有错没



___________________________________________________________________________________________________________



77. concatMap(), mergeMap(), switchMap(), and exhaustMap().几个join operator的区别
1. concatMap按顺序，内部订阅按顺序，完成一个，发出一个，发出所有值
2. mergeMap不按顺序，内部订阅谁先完成谁开始发出值，发出所有值
3. switchMap只发出最新完成的内部订阅的值，只 会发出最新值
4. exhaustMap如果前面还有内部订阅没有完成，就不会启用新的内部订阅，只会发出已经完成内部订阅的值


___________________________________________________________________________________________________________


78.takeUntil 订阅并开始镜像源 Observable 。它还监视另外一个 Observable，即你 提供的 notifier 。如果 notifier 发出值或 complete 通知，
那么输出 Observable 停止镜像源 Observable ，然后完成。
takeWhile 发出在源 Observable 中满足 predicate 函数的每个值，并且一旦出现不满足 predicate 的值就立即完成。
注: 取消订阅的三种情况
1. 执行complete
2. 执行error
3. 手动调用unsubscribe

***Note*** 当pipe里存在interval, timer, delay这类延迟执行的操作符，需要把takeUntil放在他们后面
exp: 
this.alarm$
    .asObservable()
    .pipe(
        filter(status => status === LIFT_TRIP),
        tap(() => this.trip()),
        delay(10000),
        tap(() => this.maintain()),
        delay(10000),
        catchError(() => of(null)),
        takeUntil(this.unsub$),
    ).subscribe(() => this.recovery());

___________________________________________________________________________________________________________


79*. 还是angular的变更检测问题
当组件的一个成员是对象时，在异步回调中改变此成员的某个属性，可能会导致错过变更检测(即使页面上绑定的是该成员的属性值而不是成员本身)，这种情况还是
使用detectChange来解决


___________________________________________________________________________________________________________


80.常用的javascript运算符用法
~(取反)运算符：按位取反运算符，常用于取整 ~~x
^(异或)运算符: 相同为0，不同为1,常用于变量交换 x^y
｜(或)运算: 判断奇偶，奇数 | 1 = 奇数本身

___________________________________________________________________________________________________________



81*. parseInt(0.0000005) === 1
为了安全地提取浮点数的整数部分，建议使用以下Math.floor()函数
因为parseInt(string, radiux) 如果第一个参数不是字符串，会用toString转换成string,这个时候toString(0.0000005)会得到'5e-7'



___________________________________________________________________________________________________________


82. angular表单异步加同步验证器
this.form$.pipe(
            tap(() => this.passwordForm.markAsDirty()),
            switchMap(() =>
                this.passwordForm.statusChanges.pipe(
                    startWith(this.passwordForm.status),
                    filter(status => status !== 'PENDING'),
                    take(1)
                )
            ),
            filter(status => {
                console.log(status);
                return status === 'VALID'
            })
        ).subscribe(() => {
            this.save()
        })


___________________________________________________________________________________________________________


83. jwt 全称 json web token




___________________________________________________________________________________________________________




84.node中间件：

1、中间件就是一种功能的封装方式，就是封装在程序中处理http请求的功能，

2、中间件是在管道中执行

3、中间件有一个next()函数，如果不调用next函数，请求就在这个中间件中终止了，

4、中间件和路由处理器的参数中都有回调函数，这个函数有2,3,4个参数

如果有两个参数就是req和res；

如果有三个参数就是req,res和next

如果有四个参数就是err，req，res，next

5、如果不调用next ，管道就会终止，不会再有处理器做后续响应，应该向客户端发送一个响应

6、如果调用了next，不应该发送响应到客户端，如果发送了，则后面发送的响应都会被忽略

7、中间件的第一个参数可以是路径，如果忽略则全部都匹配



___________________________________________________________________________________________________________

85.
AMD和CMD的区别

他们两者的共同点就是都是一种框架在推广的过程中对模块定义的规范产出；而且他们都是异步加载模块。

AMD即Asynchronous Module Definition,翻译过来就是异步模块化定义，是一个模块化开发的规范。此处是规范链接 那么AMD是怎么弄出来的呢？其实AMD是在RequireJS之后才出来的，是大名鼎鼎的RequireJS产出了这一套模块化开发的概念。那么谈AMD就必须先谈RequireJS.

RequireJS解决了前端开发过程中的两大问题，一个是文件之间的依赖问题，一个是浏览器加载多个JS文件时页面失去响应的时间过长。这两个问题导致人们开发出这样的一个框架来。RequireJS是外国人开发出来的，所有你可以看到，RequireJS的官网全是英文！

CMD即 common moudle definition,翻译过来即通用模块定义。此处是规范定义CMD规范是国人开发出来的，这确实为国内的前端行业争了口气了。同样的，CMD也有个浏览器的实现，这就是常常听见别人说的SeaJS了。

SeaJS和RequireJS解决的是同样的问题，然而它模块定义的方式和模块加载时机确是不同的！！！

1.RequireJS在主文件里是将所有的文件同时加载，然而SeaJS强调一个文件一个模块。

2.AMD推崇依赖前置，CMD推崇依赖就近。

什么意思呢？就是AMD在定义模块的时候要先声明其依赖的模块。例如这样：

define(['jquery'],function($){

    var  backButton=$('.backToTop');

   function  animate(){

        $('html,body').animate({

             scrollTop:0

            },800);

        };

    function scroll(){

         if($(window).scrollTop()>$(window).height())

            backButton.fadeIn();

        else

            backButton.fadeOut();

    };

    backButton.on('click',animate);

    $(window).on('scroll', scroll);

    $(window).trigger('scroll');

return{

    animate:animate,

    scroll:scroll

};

});

 

CMD没有这里严格的要求，它只要依赖的模块在附近就可以了，例如下面这样：

// CMD

define(function(require, exports, module) {

var a = require('./a')

a.doSomething()

// 此处略去 100 行

var b = require('./b') // 依赖可以就近书写

b.doSomething()

// ...

})

 

划重点了！AMD和CMD最大的区别不是说上面的两点，而是他们俩对依赖模块的执行时机有所不同！！！对依赖模块的执行时机取决于他们的模块定义方式，AMD推崇依赖前置，因此，JS可以及其轻巧地知道某个模块依赖的模块是哪一个，因此可以立即加载那个模块；而CMD是就近依赖，它要等到所有的模块变为字符串，解析一遍之后才知道他们之间的依赖关系，这在别人看来是牺牲了性能换来开发的便利性。然而我要告诉你的是解析模块用的时间短的可以忽略不计，所以这又有什么关系呢？

那么说了那么多，他们是怎么执行的呢？

AMD加载完模块后，就立马执行该模块；CMD加载完某个模块后没有立即执行而是等到遇到require语句的时再执行。

所以，他们两者的不同导致各自的优点是AMD用户体验好，因为模块提前执行了；CMD性能好，因为只有用户需要的时候才执行。

 

关于这两个的区别网上可以搜出一堆文章，简单总结一下

最明显的区别就是在模块定义时对依赖的处理不同

1、AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块
2、CMD推崇就近依赖，只有在用到某个模块的时候再去require
这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法。

AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同。

很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。

为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的。（除了名字的原因。。。）

同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行。

CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。

这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的


___________________________________________________________________________________________________________


86. 利用width: fit-content样式解决flex父元素没法被自元素宽度撑开的问题,同样也可以解决flex-auto下的元素宽度异常问题

___________________________________________________________________________________________________________


87. Angular OnPush组件
只有两种情况该组件会进行变更检测
1. ParentComponent pass new Input(必须改变变量引用) to OnPush组件 (这个时候组件自身的属性变化时不会刷新dom，此时需要手动运行detectChange())
2. 在OnPush组件内部处理**事件**(event binding, output, @hostListener),组件会运行变更检测 


___________________________________________________________________________________________________________


88. 正向代理和反向代理的区别
1. 正向代理，客户端是知道自己需要去的服务器的，需要配置代理目标到这台服务器，目标只有一个服务器
2. 反向代理，客户端并不知道自己要去哪里，由反向代理自动分配到配置的服务器，目标可能是服务器集群，这个时候是可以配置负载均衡的
打个比方，a,b,c三个人，正向代理是a通过b向C借钱，a知道c的存在 。反向代理是a向b借钱，b又向C借，a不知道c的存在。
[简单架构](https://img-blog.csdnimg.cn/20190223151528119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNTMzODUz,size_16,color_FFFFFF,t_70)

___________________________________________________________________________________________________________


***重点***
89. 两个字符串比大小，即时都可以转化为数字也不回自动转化
比如"5" > "25"是按顺序比较asc2码的顺序，所以此比较返回true


___________________________________________________________________________________________________________


90*. RegExp.prototype.test
注意test在用于带g标志的正则表达式时，是带状态的，小心用于多次test判断，这时建议取消g标志


___________________________________________________________________________________________________________



91.服务与类
在angular开发中两者适用区别
服务:
服务多用于单例模式和业务逻辑处理，有时需要保存全局状态或共享状态
比如
接口服务
全局配置数据服务
无状态功能函数服务
通信机

类:
类用于实现一个内聚的功能或模块多用于复用功能，一般不保留任何状态
比如
第3方对象封装
组件

___________________________________________________________________________________________________________


92. rem适配
        // 设计图为2560,情况下1rem = 100px; // 640以下全部不用再适配
        let pxpOneRem = doc.documentElement.clientWidth / 25.6;
            if (pxpOneRem < 60) {
                pxpOneRem = 60
            }
        docEl.style.fontSize = _rem + 'px'
        以上这段代码的意思是，2560文档宽度时 100px就是1rem，那么xxx文档宽度时候 多少px是1rem ，然后这个多少px就是body的fontsize要取的值
        所以是xxx / 25.6 那么多px


___________________________________________________________________________________________________________



93. 请求服务器静态文件时，如果nginx配置了CORS跨域请求，前端的get或者post请求不能再配置任何请求头，不然会发Options请求被跨域拦截


___________________________________________________________________________________________________________



94. 本地提供商用于有ng-content的组件查询投影内容
父组件: @ContentChildren(ChildComponentClass) xxxComponent: QueryList<ChildComponentClass> | any;
投影组件: @Component(providers: [{
		    provide: ChildComponentClass,
		    useExisting: forwardRef(() => xxxxChildComponent)
	    }])
        export xxxxChildComponent ...



___________________________________________________________________________________________________________


95. 在一个抽象的基类
export abstract class SourceComponent {
    abstract setFeatures: (data: any[]) => void// 这种是声明实例成员不是方法，子类必须有这个成员，而不能是实现该方法，这个是实例的属性
	abstract setFeatures(data: any[]): void; // 这种是声明方法而不是实例成员，子类必须实现此方法, 最后的js代码此方法挂在在构造函数的原型属性上
}


___________________________________________________________________________________________________________



96. NzTreeNode 模板布局
<span class="treelabel flex flex-items-center" *ngIf="!node.isLeaf && node.key !== ROOT_KEY">
    <i nz-icon [nzType]="node.isExpanded ? 'folder-open' : 'folder'"></i>
    <span class="text-ellipsis folder-name">{{ node.title }}</span>
</span>
<span class="treelabel flex flex-items-center" *ngIf="node.isLeaf">
    <i nz-icon nzType="file" [style.color]="origin.data.done ? '#00A006' : '#CE0000'"></i>
    <span class="text-ellipsis file-name">{{ node.title }}</span>
</span>
<span class="treelabel flex flex-items-center" *ngIf="node.key === ROOT_KEY">
    <img src="assets/image/plan/AllPlan.png" alt="All Plan" style="margin-right: 5px;" width="24">
    <span class="text-ellipsis root-name">{{ node.title }}</span>
</span>

___________________________________________________________________________________________________________



97. nz-table 超级大坑
分页参数双向绑定对象，如果属性写错直接页面崩溃，也不会报错，很难发现


___________________________________________________________________________________________________________


98. flex布局
对于一个flex的容器，有两个并列的子元素，第二个元素是含有nz-table的,最好采用一下样式
.plan-content {
        height: calc(100% - 145px);
        width: 100%;
        .left-part {
            height: 100%;
            border-right: 1px solid gray;
            margin-right: 12px;
            padding: 5px;
        }
        .right-part {
            padding: 5px;
            height: 100%;
            overflow: auto;
            border-left: 1px solid grey;
        }
    }
如果第一个元素含有nz-tree 布局错乱是由于nz-tree造成的，需要给nz-tree外面再弄一个div才能解决这个问题
 <div class="plan-content flex">
        <div class="left-part">
            <div style="width: 340px;min-height: 200px;overflow: auto">
                <hmi-plan-tree #planTree></hmi-plan-tree>
            </div>
        </div>
        <div class="right-part">
            <hmi-plan-table></hmi-plan-table>
        </div>
    </div>
___________________________________________________________________________________________________________



99. Angular中的Input传值
1. 父组件引用了子组件
2. 在父组件中改变传给子组件的变量（不是通过引用直接改子组件里的那个）
3. 在父组件中读取引用的子组件的相应的Input变量
4. 此变量不会同步更新，要等到下个变更检测周期才会变化


___________________________________________________________________________________________________________

100. 5个比较实用的原生API
1. getBoundingClientRect()
Element.getBoundingClientRect() 方法返回一个 DOMRect 对象，该对象提供有关元素大小及其相对于视口的位置的信息。
domRect = element.getBoundingClientRect();
返回左、上、右、下、x、y、宽度和高度元素的值。

Image

例如，获取DOM元素相对于页面左上角的top和left定位距离的值。

const h3 = document.querySelector("h3");
const rect = h3.getBoundingClientRect();
const topElement = document.documentElement;

const positionTop = topElement.scrollTop + rect.top;
const positionLeft = topElement.scrollLeft + rect.left;
2. window.getComputedStyle() 

window.getComputedStyle() 方法返回一个 CSSStyleDeclaration 对象，其类型与样式属性相同，其中包含元素的计算样式。

document.defaultView.getComputedStyle(element, [pseudo-element])
// or
window.getComputedStyle(element, [pseudo-element])
它有两个参数，第一个是计算样式的元素，第二个是伪元素；如果伪元素不存在，则传递 null。

例子：

<!DOCTYPE html>
<html>
<head>
    <style type="text/css">
        #root {
            background-color: pink;
            width: 100px;
            height: 200px;
        }
        #root::after {
            content: 'Haskell';
            display: table;
            clear: both;
        }
</style>
</head>
<body>
    <div id="root" style="background-color: rgb(135, 206, 235);"></div>
</body>
<script>
    function getStyleByAttr(node, name) {
        return window.getComputedStyle(node, null)[name]
    }
    const node = document.getElementById('root')
    // rgb(135, 206, 235)
    console.log(getStyleByAttr(node, 'backgroundColor'))
    // 100px
    console.log(getStyleByAttr(node, 'width'))
    // 200px
    console.log(getStyleByAttr(node, 'height'))
    // table
    console.log(window.getComputedStyle(node, '::after').display)
    // Haskell
    console.log(window.getComputedStyle(node, '::after').content)
</script>
</html>
3. once: true
once: true 不是 API，看起来也不像。用于属性配置，有了它，lodash的once就不用了。
const container = document.querySelector<HTMLDivElement>('.container');

container?.addEventListener('click', () => {
  console.log('I will only do it once !')
}, {
  // After configuring once, it will be called at most once
  once: true
})
4. getModifierState()

如果指定的修改键被按下或激活，则 getModifierState() 方法返回 true。

例如，我们可以使用它来监听用户在打字时是否按下了尺寸切换键，然后根据情况给出适当的提示。

<input type="text" size="40" onkeydown="myFunction(event)">

<p id="demo"></p>

<script>
    function myFunction(event) {
        var x = event.getModifierState("CapsLock");
        document.getElementById("demo").innerHTML = "Caps Lock: " + x;
    }
</script>
5.clipboard.readText()

clipboard，我敢肯定，是一个常用的功能。

要从剪贴板中读取文本，请调用 navigator.clipboard.readText() 并等待返回的 Promise 进行解析。

async function getClipboardContents() {
  try {
    const text = await navigator.clipboard.readText();
    console.log('Pasted content: ', text);
  } catch (err) {
    console.error('Failed to read clipboard contents: ', err);
  }
}
要将文本复制到剪贴板，只需调用 writeText()。

async function copyPageUrl() {
  try {
    await navigator.clipboard.writeText(location.href);
    console.log('Page URL copied to clipboard');
  } catch (err) {
    console.error('Failed to copy: ', err);
  }
}

___________________________________________________________________________________________________________


101. 关于angular第3方ui库，表单部分要特别小心
例如 引入一个ng-zorro的nz-select组件，在ngModel指令绑定值的时候不生效的问题
首先应该思考的是ngModel的指令是formsModule提供的angular原生指令，所以必须确保导入了相关的原生模块
然后才是看和nz-option的value值是否对应



___________________________________________________________________________________________________________



102. 在使用地图的时候，如果地图组件是应用的顶层组件，
则需要设置高度为 ** 100vh **  (***应该说，任何嵌入angular路由的顶层组件都应该这样设置***)
否则地图将无法展示



___________________________________________________________________________________________________________



103. overflow: hidden
left: 100%; 
transform: translateX(-100%);
相对于容器元素这样定位或者移动的话，会跑出容器以外，注意设置overflow:hidden，不然容器有可能会被撑大，可能会出现滚动条



___________________________________________________________________________________________________________



104. nz-slider踩坑
nz-slider因为使用了OnPush策略，而其value值不是采用input输入，所以界面并不能同步更新
直接采用ChangeDetectorRef服务进行组件变更检测，还是不起作用
原因: 一般写法上采用的是ngModel模版表单的方式进行值绑定，ngModel本身也是异步更新，所以仍然会导致错过手动的变更检测
解决办法: 直接改为响应式表单绑定，之后再采用手动变更检测就可以同步更新界面

复习: 采用OnPush的变更检测策略的组件将会停止angular本身的周期性自动变更检测
OnPush 变更检测会指示 Angular 仅在以下情况下为组件子树自动运行变更检测：

1. 子树的根组件接收到作为模板绑定的结果的新输入。Angular 将输入的当前值和过去值使用 == 进行比较， Input值引用的变化

2. Angular 处理使用了 OnPush 变更检测策略的组件中的事件时， 比如在界面上点击该组件






___________________________________________________________________________________________________________



105.svg.js分组动画

html:
<html>
<body>
 
<h1>My first SVG</h1>
 
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <rect id="test" width="100" height="50" stroke="#333"
    fill="#333"
  
  stroke-width="1"></rect>
</svg>
 
</body>
</html>


js:
const rect = document.getElementById('test');
const svgRect = SVG(rect);
const timeline = new SVG.Timeline();
svgRect.timeline(timeline);
/* svgRect.animate(4000, 0, 'absolute').move(200, 50).loop(); // start at time 0 of timeline */
/* svgRect.animate(100, 2000, 'absolute').attr({fill: '#f03'}).loop(); // start at time 200 of timeline */


___________________________________________________________________________________________________________



106. 要想控制台设备尺寸切换后，ui布局正常
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">


___________________________________________________________________________________________________________



107.FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory
set NODE_OPTIONS=--max_old_space_size=8192


___________________________________________________________________________________________________________




***108.angular的EventEmitter不要乱用变量名，取名要特别小心，比如取成select的话，会同时触发文字的选中原生select事件
直接导致意向不到的结果，$event会变成dom事件对象，而不是emit的对象



___________________________________________________________________________________________________________




***109. CMD(CommonJS) & AMD(RequireJS) 模块封装简易方法 
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    factory((global.ArcgisToGeojsonUtils = {}));
  }(this, function (exports) { 
    'use strict';
  
  
    function arcgisToGeoJSON (arcgis, idAttribute) {
     
    }
  
    function geojsonToArcGIS (geojson, idAttribute) {
    }
  
    var index = { arcgisToGeoJSON: arcgisToGeoJSON, geojsonToArcGIS: geojsonToArcGIS };
  
    exports.arcgisToGeoJSON = arcgisToGeoJSON;
    exports.geojsonToArcGIS = geojsonToArcGIS;
    exports['default'] = index;
  
  }));
  // 导入
  import ArcgisToGeojsonUtils from 'xxx/xxx.js'; 这个是把exports.defualt赋值给ArcgisToGeojsonUtils
  import * as xxx from 'xxx/xxx.js'; 这个时候的话，是吧整个exports作为一个对象赋值给了xxx



___________________________________________________________________________________________________________



