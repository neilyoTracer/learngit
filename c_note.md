1. 快速把数字char转换为int
   int num = c - '0'

2. 但是我们必须记住，[数组名] 和 [指针] 之间有一个[不同之处]。
   a. [指针是一个变量]，因此在C语言中，语句 [pa=a] 和 [pa++] 都是 *合法* 的。
   b. [但是数组名不是变量]，因此，类似于 [a=pa] 和 [a++] 形式的语句是 *非法* 的。

3. 地址算术运算 - 见[alloc.c]

4. 当对signed类型的带符号值进行右移时，某些机器将对左边空出的部分用符号位填补(即 "算术移位"), 而另一些机器则对左边空出的部分用0填补(即，"逻辑移位")

5. 如果一个指针后面有()那必然是函数指针比如 char *(* x)() pointer to function return pointer to char

6. 把函数传给接受函数指针的函数时，函数名前面不需要加上取地址运算符[&]，因为他们是函数不是变量，同样的原因，数组名前面也不需要[&]运算符

7. 在所有的运算符中, [.] [->] [()] [[]] 这4个运算符的优先级最高

8. 自动变量就是函数或者程序块定义的局部变量，不用手动管理他们的内存的创建和释放

9. 补码 = 让计算机能用相同的加法逻辑，正确地处理正数和负数
   7 -> 00000111 
   3 -> 00000011
  -3 -> 11111101(补码 3 -> 反 -> +1)

   7 + -3 = 4

   4 -> 00000100 
   执行过程
   00000111     ← +7
+  11111101     ← -3
-------------
   00000100     ← 结果为 4（补码）
   注意！加法器只保留低 8 位，高位溢出被丢弃。
   总结: 因为补码把负数编码成一个“可以直接加”的形式，所以：在硬件上，“加法器”只需支持一种操作（加法），就能处理减法！